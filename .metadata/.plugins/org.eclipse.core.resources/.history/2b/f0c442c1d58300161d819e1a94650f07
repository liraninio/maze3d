package algorithmes.mazeGenerators;

import java.util.ArrayList;
import java.util.Collections;
import java.util.Random;

//
//package algorithmes.mazeGenerators;
//
//import java.util.ArrayList;
//import java.util.Collections;
//
//
//// TODO: Auto-generated Javadoc
///**
// * The Class GrowingTreeGenerator-this class is algorithm for creating a maze3d
// */
//public abstract class GrowingTreeGenerator extends MyMaze3dGenerator {
//	
//	/** The maze. */
//	Maze3d maze;
//	
//	/** The visit. */
//	Maze3d visit;
//
//
//
//	/* (non-Javadoc)
//	 * @see algorithmes.mazeGenerators.Generator#generate(algorithmes.mazeGenerators.Position)
//	 */
//	//this is the function that creating the maze3d according to the algorithm.
//	@Override
//	public Maze3d generate(Position p1) {
//		int check=0;
//		Position newp1=new Position(p1.getX()*2+1, p1.getY()*2+1, p1.getZ()*2+1);
//		Maze3d maze=new Maze3d(newp1);
//		maze.initMaze();
//		maze.createStart();
//		Position start=maze.getStartPosition();
//		maze.setStart(start);
//		maze.createGoal();
//		Position goal=maze.getGoalPosition();
//	
//		ArrayList<Position> c =new ArrayList<Position>();
//		c.add(start);
//		maze.setCell(start.getX(),start.getY(),start.getZ(),0);
//		Position x=new Position(maze.getStartPosition());
//		do {
//			x=new Position (pop1(c));
//			Integer [] rnd= RandomDirections();
//			boolean breakLoop = false;
//
//			for (int i = 0; i < rnd.length; i++){
//				if(breakLoop==true)
//					break;
//
//				check=0;
//				switch(rnd[i]){
//				case 1:
//			
//					if(x.getX()==newp1.getX()-1) continue;
//					if(x.getX()==0)continue;
//					if(x.getZ()==0||x.getZ()==newp1.getZ()-1) continue;
//					if(x.getY()-2>=0&&((maze.getCell(x.getX(),x.getY()-2,x.getZ())==1))){
//						maze.setCell(x.getX(),x.getY()-2,x.getZ(),0);
//						maze.setCell(x.getX(),x.getY()-1,x.getZ(),0);
//						x=new Position(x.getX(),x.getY()-2,x.getZ());
//						c.add(x);
//						check++;
//						breakLoop=true;
//					}
//
//					break;
//				case 2:
//					
//					if(x.getX()==newp1.getX()-1) continue;
//					if(x.getX()==0)continue;
//					if(x.getZ()-2==0) continue;
//					if(x.getZ()-2>=0&&((maze.getCell(x.getX(),x.getY(),x.getZ()-2)==1))){
//						maze.setCell(x.getX(),x.getY(),x.getZ()-2,0);
//						maze.setCell(x.getX(),x.getY(),x.getZ()-1,0);
//						x=new Position(x.getX(),x.getY(),x.getZ()-2);
//						c.add(x);
//						check++;
//						breakLoop=true;
//					}
//
//					break;
//				case 3:
//
//					if(x.getX()==newp1.getX()-1||x.getX()-2==0) continue;
//					if(x.getZ()==0||x.getZ()==newp1.getZ()-1) continue;
//					if(x.getX()-2>=0&&((maze.getCell(x.getX()-2,x.getY(),x.getZ())==1))){
//						maze.setCell(x.getX()-1,x.getY(),x.getZ(),0);
//						maze.setCell(x.getX()-2,x.getY(),x.getZ(),0);
//						x=new Position(x.getX()-2,x.getY(),x.getZ());
//						c.add(x);
//						check++;
//						breakLoop=true;
//					}
//
//					break;
//				case 4:
//					
//					if(x.getX()==newp1.getX()-1) continue;
//					if(x.getX()==0)continue;
//					if(x.getZ()==0||x.getZ()==newp1.getZ()-1) continue;
//					if(x.getY()+2<=maze.getP().getY()&&((maze.getCell(x.getX(),x.getY()+2,x.getZ())==1))){
//						maze.setCell(x.getX(),x.getY()+2,x.getZ(),0);
//						maze.setCell(x.getX(),x.getY()+1,x.getZ(),0);
//						x=new Position(x.getX(),x.getY()+2,x.getZ());
//						c.add(x);
//						check++;
//						breakLoop=true;
//					}
//
//					break;
//
//				case 5:
//
//					if(x.getX()==newp1.getX()-1) continue;
//					if(x.getX()==0||x.getX()==newp1.getX())continue;
//					if(x.getZ()+2==newp1.getZ()-1) continue;
//					if(x.getZ()+2<=maze.getP().getZ()&&((maze.getCell(x.getX(),x.getY(),x.getZ()+2)==1))){
//						maze.setCell(x.getX(),x.getY(),x.getZ()+1,0);
//						maze.setCell(x.getX(),x.getY(),x.getZ()+2,0);
//						x=new Position(x.getX(),x.getY(),x.getZ()+2);
//						c.add(x);
//						check++;
//						breakLoop=true;
//					}
//
//
//					break;
//				case 6:
//				if(x.getX()==newp1.getX()-1) continue;
//
//					if(x.getZ()==0||x.getZ()==newp1.getZ()-1) continue;
//					Position g=new Position(x);
//					g.setX(x.getX()+2);
//					if((x.getX()+2==newp1.getX()-1)&&!(g.equals(goal))) continue;
//					if(x.getX()+2<=maze.getP().getX()&&((maze.getCell(x.getX()+2,x.getY(),x.getZ())==1))){
//						maze.setCell(x.getX()+1,x.getY(),x.getZ(),0);
//						maze.setCell(x.getX()+2,x.getY(),x.getZ(),0);
//						x=new Position(x.getX()+2,x.getY(),x.getZ());
//						c.add(x);
//						check++;
//						breakLoop=true;
//					}
//
//					break;
//
//
//				default:
//
//					break;
//
//				}
//
//			}
//
//			if(check==0)
//				c.remove(c.indexOf(x));
//
//		}while(!c.isEmpty());
//
//		return maze;
//	}
//
//
//	/**
//	 * Prints the simple maze.
//	 */
//	public void printSimpleMaze(){
//		maze.printMaze3d();
//	}
//
//	/**
//	 * Random directions.
//	 *
//	 * @return the integer[]
//	 */
//	public Integer[] RandomDirections() {//This is a function that random a number between 1-7, and put it on array.
//		ArrayList<Integer> randoms = new ArrayList<Integer>();
//		for (int i = 0; i < 6; i++)
//			randoms.add(i + 1);
//		Collections.shuffle(randoms);
//
//		return randoms.toArray(new Integer[6]);
//	}
//}
public abstract class GrowingTreeGenerator extends MyMaze3dGenerator {
Random rnd=new Random();
	
	/* (non-Javadoc)
	 * @see algorithms.mazeGenerators.Maze3dGeneratorAbstract#generate(int, int, int)
	 */
	@Override
	public Maze3d generate(Position pos){
		ArrayList<Position> C =new ArrayList<Position>();
		int z=pos.getX();
		int x=pos.getY();
		int y=pos.getZ();
		int [][][] temp=new int[(z*2)+1][(x*2)+1][(y*2)+1]; //temp array to generate the maze on times 2 plus 1 because of the walls
		for(int i=0; i<temp.length;i++) //fill it with ones
			for(int j=0; j<temp[0].length;j++)
				for(int k=0;k<temp[0][0].length;k++)
					temp[i][j][k]=1;
		
		int p1,p2,p3;
		Position c,n;
		String ns;
		boolean bool=false;
		
		//random goal position on the last floor
		Position goal;
		int goalIntX = 0,goalIntY = 0;
		goalIntX=2+(rnd.nextInt(x-1)*2); //random even number
		goalIntY=2+(rnd.nextInt(y-1)*2);
		goal= new Position(z*2,goalIntX,goalIntY);
		temp[z*2][goalIntX][goalIntY]=0;
		
		//random start position on the first floor
		p1=0;
		p2=2+(rnd.nextInt(x-1)*2);
		p3=2+(rnd.nextInt(y-1)*2);
		Position p=new Position(p1,p2,p3);
		C.add(p);
		while(!C.isEmpty()){
			c=pop1(C); // depending on users choice- random or lastcell
			temp[c.getZ()][c.getX()][c.getY()]=0;
			ArrayList<String> neighbours=UnvisitedNeighbours(temp,c); // getting all unvisited neighbours from function
			if (!neighbours.isEmpty()){
				Collections.shuffle(neighbours);
				if(c.getX()==0 && bool==false){
					bool=true;
					ns="Up";
				}
				else
					ns=neighbours.get(0);
				switch (ns){
				case "Up":
					temp[c.getX()+2][c.getY()][c.getZ()]=0;
					temp[c.getX()+1][c.getY()][c.getZ()]=0;
					n=new Position(c.getX()+2,c.getY(),c.getZ());
					if(c.getX()+2==temp.length-1){ 
						C.remove(c);
						break;
					}
					C.add(n);
					break;
				case "Forward":
					temp[c.getX()][c.getY()+2][c.getZ()]=0;
					temp[c.getX()][c.getY()+1][c.getZ()]=0;
					n=new Position(c.getX(),c.getY()+2,c.getZ());
					C.add(n);
					break;
				case "Right":
					temp[c.getX()][c.getY()][c.getZ()+2]=0;
					temp[c.getX()][c.getY()][c.getZ()+1]=0;
					n=new Position(c.getX(),c.getY(),c.getZ()+2);
					C.add(n);
					break;
				case "Down":
					temp[c.getX()-2][c.getY()][c.getZ()]=0;
					temp[c.getX()-1][c.getY()][c.getZ()]=0;
					n=new Position(c.getX()-2,c.getY(),c.getZ());
					C.add(n);
					break;
				case "BackWard":
					temp[c.getX()][c.getY()-2][c.getZ()]=0;
					temp[c.getX()][c.getY()-1][c.getZ()]=0;
					n=new Position(c.getX(),c.getY()-2,c.getZ());
					C.add(n);
					break;
				case "Left":
					temp[c.getX()][c.getY()][c.getZ()-2]=0;
					temp[c.getX()][c.getY()][c.getZ()-1]=0;
					n=new Position(c.getX(),c.getY(),c.getZ()-2);
					C.add(n);
					break;
				}
			}
			else
				C.remove(c);
		}
		Maze3d m = new Maze3d(pos); //finally setting the maze
		m.setMaze(temp);
		
		m.setStart(p);
		m.setGoal(goal);
		return m;
	}



/**
 * Unvisited neighbours.
 *
 * the function that checks for unvisited nodes
 * @param maze the maze
 * @param p the p
 * @return the array list
 */
public ArrayList<String> UnvisitedNeighbours(int [][][] maze,Position p){
	ArrayList<String> Neighbours=new ArrayList<String>();
		if((p.getZ()<=maze.length)&&(p.getX()<=maze[0].length)&&(p.getY()<=maze[0][0].length)) //range check
		{
			if (p.getX()+2<maze.length-1){ //check for out of bounds
				if(maze[p.getX()+2][p.getY()][p.getZ()]==1) //check if visited
					Neighbours.add("Up");
			}
			else if (p.getX()==maze.length-3)
				if(maze[p.getX()+2][p.getY()][p.getZ()]==0)
					Neighbours.add("Up");
				
			if (p.getY()+2<maze[0].length-1 && p.getX()!=0 && p.getX()!=maze.length-1)
				if(maze[p.getX()][p.getY()+2][p.getZ()]==1)
					Neighbours.add("Forward");
				
			if (p.getZ()+2<maze[0][0].length-1 && p.getX()!=0 && p.getX()!=maze.length-1)
				if(maze[p.getX()][p.getY()][p.getZ()+2]==1)
					Neighbours.add("Right");
			
			if (p.getX()-2>=1)
				if(maze[p.getX()-2][p.getY()][p.getZ()]==1)
					Neighbours.add("Down");
				
			if (p.getY()-2>=1 && p.getX()!=0 && p.getX()!=maze.length-1)
				if(maze[p.getX()][p.getY()-2][p.getZ()]==1)
					Neighbours.add("BackWard");
				
			if (p.getZ()-2>=1 && p.getX()!=0 && p.getX()!=maze.length-1)
				if(maze[p.getX()][p.getY()][p.getZ()-2]==1)
					Neighbours.add("Left");
		}
	return Neighbours;
}
}
